import {
  computed,
  inject,
  isSignal,
  LOCALE_ID,
  signal,
  type Signal,
} from '@angular/core';
import {
  derived,
  formGroup,
  type CreateFormGroupOptions,
  type DerivedSignal,
  type FormGroupSignal,
} from '@mmstack/form-core';
import {
  injectValidators,
  type DateRange,
  type DateValidatorOptions,
} from '@mmstack/form-validation';
import { tooltip } from '../util';
import {
  createDateState,
  type DateState,
  type DateStateOptions,
} from './base-date';

function equalDate(a: Date | null, b: Date | null): boolean {
  if (a === b) return true;
  if (!a || !b) return false;
  return a.getTime() === b.getTime();
}

type DateRangeStateChildren<TDate = Date> = {
  start: DateState<DateRange<TDate>, TDate>;
  end: DateState<DateRange<TDate>, TDate>;
};

/**
 * Represents the reactive state for a date range input form group.
 *
 * Extends the base `FormGroupSignal<DateRange<TDate>>` and adds date-specific
 * properties like `placeholder` and enhanced `error`/`errorTooltip` signals derived
 * from the validation result's `.resolve()` method (when using the injected factory).
 *
 * @template TParent The type of the parent form group's value, if applicable. Defaults to `undefined`.
 * @template TDate The type used for date values within the control (e.g., `Date`, Luxon `DateTime`, Moment). Defaults to `Date`.
 * @see FormGroupSignal
 * @see DateState
 */
export type DateRangeState<TParent = undefined, TDate = Date> = FormGroupSignal<
  DateRange<TDate>,
  DateRangeStateChildren<TDate>,
  TParent
> & {
  /**
   * Signal holding the formatted error message suitable for tooltips or detailed display.
   * When multiple validation errors occur, this may contain all messages, while `error()` might show a summary.
   * (Generated by `injectCreateDateRangeState` using the validator's `.resolve()` method, or shortened by provided maxErrorHintLength).
   */
  errorTooltip: Signal<string>;
  /** signal for hint tooltip, default is shortened when hint is longer than 40 chars */
  hintTooltip: Signal<string>;
  /**
   * Signal holding the minimum selectable date (inclusive), derived from options.
   * Returns `null` if no minimum date is set. The value is always a `Date` object internally
   * for reliable comparison, regardless of the input option format (`string` or `Date`).
   * Useful for binding to date picker component properties (e.g., `[min]`).
   */
  min: Signal<Date | null>;
  /**
   * Signal holding the maximum selectable date (inclusive), derived from options.
   * Returns `null` if no maximum date is set. The value is always a `Date` object internally.
   * Useful for binding to date picker component properties (e.g., `[max]`).
   */
  max: Signal<Date | null>;
  /** Type discriminator for date-range controls. */
  type: 'date-range';
};

/**
 * Optional configuration for the `from/to` date state.
 * This allows you to customize the behavior of the `from` date input.
 * you can provide specific options such as placeholder.
 */
type ChildDateStateOptions<TDate = Date> = Omit<
  DateStateOptions<TDate>,
  | 'locale'
  | 'min'
  | 'max'
  | 'label'
  | 'disable'
  | 'readonly'
  | 'maxErrorHintLength'
>;

/**
 * Configuration options for the `createDateRangeState` function (the non-DI version).
 * Extends base form group options for a `DateRange<TDate>` value.
 *
 * @template TDate The type used for date values. Defaults to `Date`.
 * @see CreateFormGroupOptions
 * @see createDateRangeState
 */
export type DateRangeStateOptions<TDate = Date> = CreateFormGroupOptions<
  DateRange<TDate>,
  DateRangeStateChildren<TDate>
> & {
  /**
   * The locale string (e.g., 'en-US', 'de-DE'). While required by this type,
   * it's primarily intended to be passed down internally when using the
   * dependency-injected factory (`injectCreateDateRangeState`) which obtains it from `LOCALE_ID`.
   * If using `createDateRangeState` directly, you must provide it manually, but its primary
   * use is within the validation message formatting handled by the injected system.
   */
  locale: string;
  /**
   * Optional function returning the minimum selectable date (inclusive).
   * Accepts a string (parsed as `new Date(string)`), a `Date` object, or `null`.
   * Populates the `min` signal on the `DateRangeState`.
   * Note: If using `injectCreateDateRangeState`, setting `min` via the `validation`
   * options is generally preferred as it enables validation messages.
   */
  min?: () => string | Date | null;
  /**
   * Optional function returning the maximum selectable date (inclusive).
   * Accepts a string (parsed as `new Date(string)`), a `Date` object, or `null`.
   * Populates the `max` signal on the `DateRangeState`.
   * Note: If using `injectCreateDateRangeState`, setting `max` via the `validation`
   * options is generally preferred as it enables validation messages.
   */
  max?: () => string | Date | null;
  /* shortens error/hint message & provides errorTooltip with full message, default 40 */
  maxErrorHintLength?: () => number;
  /** Optional configuration applied specifically to the 'start' date input control (e.g., setting a placeholder). */
  start?: ChildDateStateOptions<TDate>;
  /** Optional configuration applied specifically to the 'end' date input control (e.g., setting a placeholder). */
  end?: ChildDateStateOptions<TDate>;
};

/**
 * Creates the reactive state object (`DateRangeState`) for a date range form control
 * without relying on Angular's dependency injection for validation or locale.
 *
 * Internally creates a `formGroup` with `start` and `end` `DateState` children
 * using the non-DI `createDateState` function. It computes overall `min`/`max` signals
 * based directly on the provided `opt.min` and `opt.max` options.
 *
 * Prefer `injectCreateDateRangeState` for standard usage within Angular applications to leverage
 * automatic validation integration, localization, and enhanced error display.
 *
 * @template TParent The type of the parent form group's value, if applicable. Defaults to `undefined`.
 * @template TDate The type used for date values. Defaults to `Date`.
 * @param value The initial date range value (`DateRange<TDate>`, e.g., `{ start: TDate|null, end: TDate|null }`),
 * or a `DerivedSignal` linking it to a parent state.
 * @param opt Configuration options (`DateRangeStateOptions`). Requires `locale`. Allows specifying options
 * for the child `start`/`end` inputs via `opt.start`/`opt.end`.
 * @returns A `DateRangeState` instance managing the control's reactive state.
 * @see injectCreateDateRangeState
 * @see DateRangeStateOptions
 * @see formGroup
 * @see createDateState
 */
export function createDateRangeState<TParent = undefined, TDate = Date>(
  value: DateRange<TDate> | DerivedSignal<TParent, DateRange<TDate>>,
  opt: DateRangeStateOptions<TDate>,
): DateRangeState<TParent, TDate> {
  const valueSignal = isSignal(value) ? value : signal(value);

  const min = computed(
    () => {
      const m = opt.min?.();
      if (typeof m === 'string') return new Date(m);
      if (m instanceof Date) return m;
      return null;
    },
    {
      equal: equalDate,
    },
  );

  const max = computed(
    () => {
      const m = opt.max?.();
      if (typeof m === 'string') return new Date(m);
      if (m instanceof Date) return m;
      return null;
    },
    {
      equal: equalDate,
    },
  );

  const children: DateRangeStateChildren<TDate> = {
    start: createDateState(derived(valueSignal, 'start'), {
      ...opt.start,
      locale: opt.locale,
    }),
    end: createDateState(derived(valueSignal, 'end'), {
      ...opt.end,
      locale: opt.locale,
    }),
  };

  const state = formGroup<
    DateRange<TDate>,
    DateRangeStateChildren<TDate>,
    TParent
  >(valueSignal, children, opt);

  const { shortened: error, tooltip: errorTooltip } = tooltip(
    state.error,
    opt.maxErrorHintLength,
  );
  const { shortened: hint, tooltip: hintTooltip } = tooltip(
    state.hint,
    opt.maxErrorHintLength,
  );

  return {
    ...state,
    min,
    max,
    error,
    errorTooltip,
    hint,
    hintTooltip,
    type: 'date-range',
  };
}

/**
 * Configuration options specifically for the factory function returned by
 * `injectCreateDateRangeState`.
 *
 * Extends `DateRangeStateOptions` but omits properties handled internally by the factory
 * (`locale`, `required`, `validator`, `min`, `max`). Requires validation rules for the
 * *date range itself* (including overall `min`/`max` constraints which also drive the state's signals)
 * via the `validation` property using `DateValidatorOptions`.
 *
 * **Assumption:** It's expected that `@mmstack/form-validation` provides range-specific validation logic
 * (like ensuring start <= end) accessible via `validators.dateRange.all(...)` when interpreting
 * the provided `DateValidatorOptions`.
 *
 * @template TDate The type used for date values. Defaults to `Date`.
 * @see injectCreateDateRangeState
 * @see DateRangeStateOptions
 * @see DateValidatorOptions
 */
export type InjectedDateRangeStateOptions<TDate = Date> = Omit<
  DateRangeStateOptions<TDate>,
  'locale' | 'required' | 'validator' | 'min' | 'max' // Handled by DI / validation prop
> & {
  /**
   * Optional function returning `DateValidatorOptions`. Defines validation rules for the
   * *entire date range* object (e.g., required start/end, overall min/max constraints,
   * potentially range validity like start <= end if supported by `validators.dateRange.all`).
   * The `min` and `max` specified here also populate the `DateRangeState`'s `min`/`max` signals.
   * @example validation: () => ({ required: true, min: new Date(), range: true }) // Assuming 'range' rule exists
   */
  validation?: () => DateValidatorOptions; // Uses options for single dates, interpreted for range
};

/**
 * Creates and returns a factory function for generating `DateRangeState` instances.
 *
 * This factory utilizes Angular's dependency injection (`injectValidators`, `LOCALE_ID`)
 * to automatically handle validation configuration (expecting range-specific rules like start <= end
 * via `validators.dateRange.all` interpreting `DateValidatorOptions`), localization, and enhanced
 * error message formatting (`error`/`errorTooltip`). The overall `min`/`max` signals on the state
 * are also automatically derived from the `min`/`max` constraints provided within the `validation` options.
 *
 * This is the **recommended** way to create `DateRangeState` within an Angular application.
 *
 * @returns A factory function: `(value: DateRange<TDate> | DerivedSignal<TParent, DateRange<TDate>>, opt?: InjectedDateRangeStateOptions<TDate>) => DateRangeState<TParent, TDate>`.
 * @template TDate The type used for date values. Defaults to `Date`. Must match type used in `provideValidatorConfig`.
 * @template TParent The type of the parent form group's value, if applicable. Defaults to `undefined`.
 *
 * @example
 * // Within an injection context:
 * const createDateRange = injectCreateDateRangeState();
 * // Assuming DateRange = { start: Date | null, end: Date | null }
 *
 * const vacationDatesState = createDateRange({ start: null, end: null }, {
 * label: () => 'Vacation Dates',
 * start: { placeholder: () => 'Departure Date' }, // Child control options
 * end: { placeholder: () => 'Return Date' },
 * validation: () => ({ // Validation for the range
 * required: true,       // Requires both start and end
 * min: new Date(),      // Overall minimum date for picker & validation
 * // Assumes validation library has a rule triggered by DateValidatorOptions
 * // that checks if start <= end, potentially enabled by default or specific flag
 * })
 * });
 *
 * // Template binds to child states for inputs:
 * // <mat-date-range-input [formGroup]="vacationDatesFormGroup"> * //  <input matStartDate [(ngModel)]="vacationDatesState.children().start.value" [placeholder]="vacationDatesState.children().start.placeholder()">
 * //  <input matEndDate [(ngModel)]="vacationDatesState.children().end.value" [placeholder]="vacationDatesState.children().end.placeholder()">
 * // </mat-date-range-input>
 * // <mat-date-range-picker [min]="vacationDatesState.min()" [max]="vacationDatesState.max()"></mat-date-range-picker>
 */
export function injectCreateDateRangeState() {
  const locale = inject(LOCALE_ID);
  const validators = injectValidators();

  /**
   * Factory function (returned by `injectCreateDateRangeState`) that creates `DateRangeState`.
   * Integrates with `@mmstack/form-validation` via DI for validation (using `validators.dateRange.all`),
   * localization, and enhanced error display. Derives overall `min`/`max` signals from validation options.
   *
   * @template TDate The type for date values used by this control. Defaults to `Date`.
   * @template TParent The type of the parent form group's value, if applicable. Defaults to `undefined`.
   * @param value The initial date range value (`DateRange<TDate>`), or a `DerivedSignal` linking it.
   * @param opt Configuration options (`InjectedDateRangeStateOptions`), including options for child
   * `start`/`end` controls and the `validation` property (accepting `DateValidatorOptions`
   * to be interpreted for range validation by `validators.dateRange.all`).
   * @returns A `DateRangeState` instance managing the control's reactive state.
   */
  return <TDate = Date, TParent = undefined>(
    value: DateRange<TDate> | DerivedSignal<TParent, DateRange<TDate>>,
    opt?: InjectedDateRangeStateOptions<TDate>,
  ): DateRangeState<TParent, TDate> => {
    const validationOptions = computed(() => ({
      messageOptions: {
        label: opt?.label?.(),
      },
      ...opt?.validation?.(),
    }));

    const min = computed(() => validationOptions().min ?? null);
    const max = computed(() => validationOptions().max ?? null);

    const mergedValidator = computed(() =>
      validators.dateRange.all(validationOptions()),
    );

    type ValidatorParam = Parameters<ReturnType<typeof mergedValidator>>[0];

    const validator = computed(() => {
      const merged = mergedValidator();
      return (value: DateRange<TDate>) => {
        return merged(value as ValidatorParam);
      };
    });

    const state = createDateRangeState<TParent, TDate>(value, {
      ...opt,
      locale,
      min,
      max,
      validator,
      required: computed(() => validationOptions().required ?? false),
    });

    const resolvedError = computed(() => {
      const merger = mergedValidator();

      return merger.resolve(state.errorTooltip() || state.error());
    });

    return {
      ...state,
      error: computed(() => resolvedError().error),
      errorTooltip: computed(() => resolvedError().tooltip),
    };
  };
}
