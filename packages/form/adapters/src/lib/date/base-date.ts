import { computed, inject, LOCALE_ID, type Signal } from '@angular/core';
import {
  type CreateFormControlOptions,
  type DerivedSignal,
  formControl,
  FormControlSignal,
} from '@mmstack/form-core';
import {
  type DateValidatorOptions,
  injectValidators,
} from '@mmstack/form-validation';

/**
 * Represents the reactive state for a date input form control.
 *
 * Extends the base `FormControlSignal<TDate | null>` and adds date-specific
 * properties like `placeholder` and enhanced `error`/`errorTooltip` signals derived
 * from the validation result's `.resolve()` method (when using the injected factory).
 *
 * @template TParent The type of the parent form group's value, if applicable. Defaults to `undefined`.
 * @template TDate The type used for date values within the control (e.g., `Date`, Luxon `DateTime`, Moment). Defaults to `Date`.
 * @see FormControlSignal
 */
export type DateState<TParent = undefined, TDate = Date> = FormControlSignal<
  TDate | null, // Value can be the specific date type or null
  TParent
> & {
  /** Signal holding the input placeholder text (e.g., "YYYY-MM-DD"). */
  placeholder: Signal<string>;
  /**
   * Signal holding the formatted error message suitable for tooltips or detailed display.
   * When multiple validation errors occur, this may contain all messages, while `error()` might show a summary.
   * (Generated by `injectCreateDateState` using the validator's `.resolve()` method).
   */
  errorTooltip: Signal<string>;
  /** Type discriminator for date controls. */
  type: 'date';
};

/**
 * Configuration options for the `createDateState` function (the non-DI version).
 * Extends base form control options for a `TDate | null` value.
 *
 * @template TDate The type used for date values. Defaults to `Date`.
 * @see CreateFormControlOptions
 * @see createDateState
 */
export type DateStateOptions<TDate = Date> = CreateFormControlOptions<
  TDate | null,
  'control'
> & {
  /**
   * The locale string (e.g., 'en-US', 'de-DE'). While required by this type,
   * it's primarily intended to be passed down internally when using the
   * dependency-injected factory (`injectCreateDateState`) which obtains it from `LOCALE_ID`.
   * If using `createDateState` directly, you must provide it manually, but its primary
   * use is within the validation message formatting handled by the injected system.
   */
  locale: string;
  /** Optional function returning the placeholder text for the date input. */
  placeholder?: () => string;
};

/**
 * Configuration options specifically for the factory function returned by
 * `injectCreateDateState`.
 *
 * This type omits base properties handled internally by the factory (like `validator`, `required`, `locale`)
 * and requires validation rules to be provided via the `validation` property using `DateValidatorOptions`
 * from `@mmstack/form-validation`.
 *
 * @template TDate The type used for date values. Defaults to `Date`.
 * @see injectCreateDateState
 * @see DateStateOptions
 * @see DateValidatorOptions
 */
export type InjectedDateStateOptions<TDate = Date> = Omit<
  // Options related to validation rules or locale are handled internally
  DateStateOptions<TDate>,
  'required' | 'validator' | 'locale'
> & {
  /**
   * Optional function returning a `DateValidatorOptions` object defining the validation rules.
   * The factory function uses this configuration with the injected `validators.date.all()` method
   * to create the combined validator for the date control.
   *
   * @example validation: () => ({ required: true, min: new Date() })
   */
  validation?: () => DateValidatorOptions;
};

/**
 * Creates the reactive state object (`DateState`) for a date form control
 * without relying on Angular's dependency injection for validation or locale.
 *
 * Use this function directly only if creating state outside an injection context
 * or providing a fully custom `validator` and `locale` manually via the `opt` parameter.
 * Prefer `injectCreateDateState` for standard usage within Angular applications.
 *
 * Note: The `errorTooltip` signal returned by this function will initially be empty.
 * Enhanced tooltip generation based on multiple errors is handled by `injectCreateDateState`.
 *
 * @template TParent The type of the parent form group's value, if applicable. Defaults to `undefined`.
 * @template TDate The type used for date values. Defaults to `Date`.
 * @param value The initial date value (`TDate | null`), or a `DerivedSignal` linking it to a parent state.
 * @param opt Configuration options (`DateStateOptions`), requires `locale` and optionally `validator`, `placeholder`, etc.
 * @returns A `DateState` instance managing the control's reactive state.
 * @see injectCreateDateState
 */
export function createDateState<TParent = undefined, TDate = Date>(
  value: TDate | null | DerivedSignal<TParent, TDate | null>,
  opt: DateStateOptions<TDate>,
): DateState<TParent, TDate> {
  const state = formControl<TDate | null, TParent>(value, opt);

  return {
    ...state,
    placeholder: computed(() => opt.placeholder?.() ?? ''),
    errorTooltip: computed(() => ''),
    type: 'date',
  };
}

/**
 * Creates and returns a factory function for generating `DateState` instances.
 *
 * This factory utilizes Angular's dependency injection (`injectValidators`, `LOCALE_ID`)
 * to automatically handle validation configuration (via `DateValidatorOptions` passed
 * to the `validation` option), localization for default error messages, and enhanced
 * error message formatting (splitting merged errors into `error` and `errorTooltip` signals).
 * It also automatically configures date handling based on `provideValidatorConfig`.
 *
 * This is the **recommended** way to create `DateState` within an Angular application.
 *
 * @returns A factory function: `(value: TDate | null | DerivedSignal<TParent, TDate | null>, opt?: InjectedDateStateOptions<TDate>) => DateState<TParent, TDate>`.
 * @template TDate The type used for date values passed to the factory (e.g., `Date`, Luxon `DateTime`).
 * Must match the `TDate` used during `provideValidatorConfig` if custom date handling is required. Defaults to `Date`.
 *
 * @example
 * // Within an injection context (component, service, etc.):
 * const createDate = injectCreateDateState();
 * // If using Luxon: const createDate = injectCreateDateState<DateTime>();
 *
 * const deliveryDateState = createDate(null, {
 * label: () => 'Delivery Date',
 * placeholder: () => 'Select a date',
 * validation: () => ({ required: true, min: new Date() }) // Use DateValidatorOptions
 * });
 *
 * // Template might use:
 * // <my-date-picker [state]="deliveryDateState"></my-date-picker>
 * // Error Display:
 * // <mat-error>
 * //   <span [matTooltip]="deliveryDateState.errorTooltip()">{{ deliveryDateState.error() }}</span>
 * // </mat-error>
 */
export function injectCreateDateState() {
  const validators = injectValidators();
  const locale = inject(LOCALE_ID);

  /**
   * Factory function (returned by `injectCreateDateState`) that creates `DateState`.
   * Integrates with `@mmstack/form-validation` via DI for validation and localization.
   * Handles splitting of multiple validation errors into `error` and `errorTooltip`.
   *
   * @template TDate The type for date values used by this control. Defaults to `Date`.
   * @template TParent The type of the parent form group's value, if applicable. Defaults to `undefined`.
   * @param value The initial date value (`TDate | null`), or a `DerivedSignal` linking it to a parent state.
   * @param opt Configuration options (`InjectedDateStateOptions`), including the `validation` property
   * which accepts `DateValidatorOptions` for rule definition.
   * @returns A `DateState` instance managing the control's reactive state, including separate
   * `error` (for primary display) and `errorTooltip` (for detailed/multiple errors) signals.
   */
  return <TDate = Date, TParent = undefined>(
    value: TDate | null | DerivedSignal<TParent, TDate | null>,
    opt?: InjectedDateStateOptions<TDate>,
  ) => {
    const validationOptions = computed(() => ({
      messageOptions: {
        label: opt?.label?.(),
      },
      ...opt?.validation?.(),
    }));

    const mergedValidator = computed(() =>
      validators.date.all(validationOptions()),
    );

    const validator = computed(() => {
      const merged = mergedValidator();

      return (value: TDate | null) => {
        return merged(value as Date);
      };
    });

    const state = createDateState(value, {
      ...opt,
      locale,
      required: computed(() => opt?.validation?.()?.required ?? false),
      validator,
    });

    const resolvedError = computed(() => {
      const merger = mergedValidator();

      return merger.resolve(state.error());
    });

    return {
      ...state,
      error: computed(() => resolvedError().error),
      errorTooltip: computed(() => resolvedError().tooltip),
    };
  };
}
